name: External Trigger Unity Primary

on:
  workflow_dispatch:

jobs:
  run-python:
    runs-on: windows-latest

    env:
      ASSET_RIPPER_VERSION: "0.3.4.0"

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.bla }}
        fetch-depth: 0

    - name: Download CloudFront file
      run: |
        curl.exe -L "${{secrets.link1}}" -o target.bin

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"

    - name: Install UnityPy
      run: |
        python -m pip install --upgrade pip
        pip install UnityPy

    - name: List down all the chapter.asset
      run: |
        python "chapter.py" "target.bin"

    - name: Download CloudFront files only if updated
      run: |
        $base_url = "${{secrets.link2}}"
        $etag_file = "etag_store.txt"

        # Load previous ETags
        $existing_etags = @{}
        if (Test-Path $etag_file) {
            $lines = Get-Content $etag_file
            foreach ($line in $lines) {
                if ($line -match "^(.*)\|(.*)$") {
                    $existing_etags[$matches[1]] = $matches[2]
                }
            }
        }

        $new_etags = @{}

        Get-Content outputs.txt | ForEach-Object {
            $file_name = $_.Trim()
            $url = "$base_url/$file_name"

            # Send HEAD request to get ETag or Last-Modified
            $response = Invoke-WebRequest -Uri $url -Method Head
            $etag = $response.Headers.ETag
            if (-not $etag) { $etag = $response.Headers.'Last-Modified' }

            $new_etags[$file_name] = $etag

            # Compare with previous ETag
            if ($existing_etags.ContainsKey($file_name) -and $existing_etags[$file_name] -eq $etag) {
                Write-Host "$file_name is up-to-date, skipping download."
            } else {
                Write-Host "Downloading updated file: $url"
                curl.exe -L $url -o (Split-Path $file_name -Leaf)
            }
        }

        # Save new ETags
        $new_etags.GetEnumerator() | ForEach-Object { "$($_.Key)|$($_.Value)" } | Set-Content $etag_file

    - name: Download & unzip AssetRipper
      run: |
        curl.exe -L "https://github.com/AssetRipper/AssetRipper/releases/download/${env:ASSET_RIPPER_VERSION}/AssetRipper_win_x64.zip" -o AssetRipper.zip
        Expand-Archive AssetRipper.zip -DestinationPath AssetRipper

    - name: Run AssetRipper on updated chapter.assets
      run: |
        Get-ChildItem -Path . -Filter "*.asset" | ForEach-Object {
            $asset_file = $_.FullName
            $output_dir = "rip_output\$($_.BaseName)"

            # Skip if already ripped
            if (Test-Path $output_dir) {
                Write-Host "$asset_file already ripped, skipping."
            } else {
                .\AssetRipper\AssetRipper.exe $asset_file -o $output_dir -q > $null 2>&1
            }
        }

    - name: Save output list
      run: |
        (Get-ChildItem -Recurse rip_output | Select-Object FullName) | Out-File output.txt

    - name: Push to private repo
      run: |
        git config --global user.name "github-actions"
        git config --global user.email "actions@github.com"

        # Clone the target repo
        git clone https://${{ secrets.OTHER_REPO_TOKEN }}@${{ secrets.github }} target-repo
        cd target-repo

        # Create folder if missing
        if (-Not (Test-Path -Path "generated")) {
            New-Item -ItemType Directory -Path "generated"
        }

        # Copy new files
        Copy-Item ../output.txt generated/ -Force
        Copy-Item ../outputs.txt generated/ -Force
        Copy-Item ../*.asset generated/ -Force

        git add .
        git commit -m "Update generated chapter assets" || echo "No changes to commit"
        git push origin main
